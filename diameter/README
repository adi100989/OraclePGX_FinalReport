[A]	DIAMETER CALCULATION:
	
	We first describe why exact computation is infeasible. Assume we have a ‘set’ data structure that supports two functions: add() for adding an item, and size() for returning the count of distinct items. With the set, radii of nodes can be computed as follows: 
(1) For each node i, make a set Si and initialize by adding i to it. 
(2) For each node i, update Si by adding one-step neighbors of i to Si. 
(3) For each node i, continue updating Si by adding 2,3,...-step neighbors of i to Si. If the size of Si before and after the addition does not change, then the node i reached its radius. Iterate until all nodes reach their radii. 


Although simple and clear, the above algorithm requires too much space, O(n2), since there are n nodes and each node requires n space in the end. Since exact implementation is hopeless, we turn to an approximation algorithm for the effective radius and the diameter computation. 


For the purpose, we use the Flajolet-Martin algorithm [Flajolet and Martin 1985; Palmer et al. 2002] for counting the number of distinct elements in a multiset. While many other applicable algorithms exist (e.g., [Beyer et al. 2007; Charikar et al. 2000; Garofalakis and Gibbon 2001]), we choose the Flajolet-Martin algorithm because it gives an unbiased estimate, as well as a tight O(log n) bound for the space complexity [Alon et al. 1996].



[B]	LIMITATIONS in GM coding:
	

	1. vect<bool>[vector_length] Z : cannot be defined - tested in bug_testing_1.gm how to work around that situation

	2. since vector of boolean values can't be defined - boolean operations like shift ,  masking , bitwise OR can't be performed 
		explicitely writing code to iterate through all indices of a vector of int.
		
		SAMPLE: (BITWISE- OR)
			---------------------------------------------------------------------------------------------------------
				vect<int>[vector_length] bs3 = i.bitString_H;
				vect<int>[vector_length] bs1 = i.bitString_H_prev;
                                vect<int>[vector_length] bs2 = nbr.bitString_H_prev;
                                while(index < vector_length)
                                {
                                        bool x = (bs1[index] == 1) ||(bs2[index] == 1);
                                        index += 1;                               
                                        if(x) bs3[index] = 1;
                                        else bs3[index] = 0;

                                }
                                i.bitString_H = bs3;

			---------------------------------------------------------------------------------------------------------

	3. vector can only be defined for primitive types like int , long, float and double - pg 25 - "greenmarl language specification"

	4. N_P vectors can't be accessed via indices -- see bug_testing_1.gm -- shows error
		Workaround:
			1. a simple vector of primitve type can be accessed via indices
			2. so to make changes to only some vector indices or traversing & changing a value - need to create a temporary vector
			3. Make the necessary changes and reassign it as a N_P vector
 
			SAMPLE:
				----------------------------------------------------------------------------------------------
				int index = 0;
                                vect<int>[vector_length] bs3 = i.bitString_H;
                                vect<int>[vector_length] bs1 = i.bitString_H_prev;
                                vect<int>[vector_length] bs2 = nbr.bitString_H_prev;
                                while(index < vector_length)
                                {
                                        //bool x = (i.bitString_H_prev[index] == 1) ||(nbr.bitString_H_prev[index] == 1);
                                        bool x = (bs1[index] == 1) ||(bs2[index] == 1);
                                        index += 1;
                                        //if(x) i.bitString_H[index] = 1;
                                        //else i.bitString_H[index] = 0;
                                        if(x) bs3[index] = 1;
                                        else bs3[index] = 0;

                                }
                                i.bitString_H = bs3;
				---------------------------------------------------------------------------------------------------
 
	
	5. This copying to and fro from temporary bector to a N_P vector is cause an error while parallel executiom:
		THIS DOES NOT WORK WHEN THE LINES ARE UNCOMMENTED DUE TO INCONSITENCY:
			------------------------------------------------------------------------------------------------------------
			 foreach(n : g.nodes)
			        {
                			vect<int>[vector_length] bs = 0;        //vect<bool>[vetor_length] doesn't work- tested in bug_testing_1.gm
                			bs[n.ID] = 1;
                			n.bitString_H_prev = bs;                        //newFMbitstring assigned to every node
                			//bs[n.ID] = 1;
                			n.bitString_H = bs;
               	 			n.hop = 0;                              //initialize first hop as 0
        				//      vect<int>[vector_length] Z=  n.bitString_H;
        				//      K += Z[n.ID];
        			}
			-------------------------------------------------------------------------------------------------------------
	
	6. Similarly in the above code if K is returned from the foreach loop , throws an error that all the loops could not complete execution and couldn't return values.
 




[C] 	REFERENCES:

	1. PowerGraph/toolkits/graph_analytics/approximate_diameter.cpp
	2. http://people.seas.harvard.edu/~babis/tkdd10.pdf
	3. https://en.wikipedia.org/wiki/Flajolet%E2%80%93Martin_algorithm
	4. http://reports-archive.adm.cs.cmu.edu/anon/ml2008/CMU-ML-08-117.pdf




