/****************************************************************************************************************************************** 
*	Although simple and clear, the exact algorithm requires too much space, O(n2), since there are n nodes and each node 
*	requires n space in the end. An approximation algorithm for the effective radius and the diameter computation is thus chosen.
*	For the purpose, we use the Flajolet-Martin algorithm for counting the number of distinct elements in a multiset. While many 
*	other applicable algorithms exist, we choose the Flajolet-Martin algorithm because it gives an unbiased estimate, as well as a
*	tight O(log n) bound for the space complexity.
*	ALGORITHM:
*	input : Edge file E = {(ki, kj )} - 
*		MaxIter = 256 and K = 32 (as per the paper) - but taking K = 1
*	output: Diameter d,
*		Neighborhood N(h) where 1 ≤ h ≤ d
*
*******************************************************************************************************************************************/

procedure approxDiameter( g:graph , ID : N_P <int>(g), vector_length : int; radius : nodeProp<int>(g) ,link_node : nodeProp<vect<int>[vector_length]>):int
{
 	if( g.numNodes()<=1 ) return 0;
	
	int maxIter = 256;	//MaxIter is set to 256 since real graphs have relatively small effective diameter. 
	int K = 1; 		//The parameter K is typically set to 32[Flajolet and Martin 1985]  
				//but since vector of vectors can't be made in GM , I am taking k = 1 	

	N_P <vect<int>[vector_length]>(g) bitString_H;
	N_P <vect<int>[vector_length]>(g) bitString_H_prev;	
	N_P <int>(g) hop;
	foreach(n : g.nodes)
	{	
		vect<int>[vector_length] bs = 0; //vect<bool>[vetor_length] doesn't work- tested in bug_testing_1.gm
		n.bitString_H = bs;
		n.bitString_H_prev = bs;
		n.h = 1;
	}
	int h_max = 0;	
	int h = 1; 	//start with hop distance = 1
	while(h <= maxIteration)
	{
		int changed  = 0;
		foreach( i : g.nodes)
		{
			foreach( nbr : i.nbrs )
			{
				//for(index : i.bitString_H.items)
				int index = 0;
				while(index < vector_length)
				{
					bool x = (i.bitString_H_prev[index] == 1) ||(nbr.bitString_H_prev[index] == 1);
					index += 1;
					if(bool) i.bitString_H[index] = 1;
					else i.bitString_H[index] = 0;	
				}
			}
				
		i.hop += 1; //increase the hop value by one
		if(i.bitString_H != i.bitString_H_prev )
			changed += 1;		
		}	
		
		if(changed == 0)
		{
			h_max = h;
			h = maxIteration+1; 	// to break while loop
		}
	}

/*
	foreach(x : g.nodes)
	{			
		int c = 0;	
		vect<int>[vector_length] Z;
		N_S(g) nbr;
		foreach(s : x.nbrs)
			nbr.add(s);
		for(y : g.nodes)
		{	
			if((x.ID != y.ID) && !( nbr.has(y)))
			{	
				c = 0;
				foreach(s : y.nbrs)
				{
					if(nbr.has(s))
						c += 1;
				}
				Z[y.ID] = c;
				x.link_node= Z;
			}
		}

 	}
	return g.numNodes();
*/
}

